# Архитектура сложных веб приложений. Адель Файзрахманов

3. Внедрение зависимостей

    - Принцип Единственной Ответственности (Single Responsibility Principle, SRP)

        - Класс должен иметь лишь одну причину для изменения

        - Связность (cohesion) - это степень того, как методы одного класса (или части другой
          программной единицы: функции, модуля) сконцентрированы на главной цели этого класса

        - Связанность (coupling) между двумя классами (функциями, модулями) - это степень того,
          как много они знают друг о друге. При сильной связанности изменение в одной части кода
          может привести к каскаду изменения в других частях.

    - Dependency Injection

        - Нужно избегать жестких зависимостей

            ```php
            // непосредственное создание экземпляра класса
            $imageUploader = new ImageUploader();

            // вызов статического метода
            ImageUploader::upload(...);

            // лучше внедрить зависимости через конструктор
            public function __construct(
            Storage $storage, ThumbCreator $thumbCreator)
            {
            $this->storage = $storage;
            $this->thumbCreator = $thumbCreator;
            }
            ```

        - В обычном проекте зависимости на реальные классы, а не на интерфейсы, — абсолютно нормальная практика.
          Классы достаточно легко преобразовать в интерфейсы, если это потребуется. Простые имена интерфейсов
          предпочтительны: Storage лучше, чем StorageInterface или App\Contracts\Storage

    - Наследование

        Когда наследуются от неабстрактного класса, то у этого класса на высоком уровне образуются
        две ответственности: перед собственными клиентами и перед наследниками, которые тоже
        используют его функционал. Вторая ответственность не очень явная и довольно легко сделать
        ошибку, которая приведёт к сложным и трудноуловимым багам. Чтобы избежать подобных осложнений,
        я в своих проектах все неабстрактные классы помечаю как final, запрещая наследование от них.

        Каждое использование ключевого слова protected создаёт неявную связь между классами предка
        и наследника. Изменения в классе могут породить баги в наследниках.

        Механизм внедрения зависимостей предоставляет возможность просто пробросить нужный функционал,
        без необходимости наследоваться.

    - Пример с загрузкой картинок

        Название класса BanUserCommand быстро позволяет понять, что он делает, без заглядывания внутрь

        ```php
        final class BanUserCommand
        {
            public function banUser(User $user)
            {
                $user->banned = true;
                $user->save();
            }
        }
        ```

